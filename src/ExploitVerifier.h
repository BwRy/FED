#pragma once
#include <map>
#include <vector>
#include <boost/thread/thread.hpp>
#include <boost/thread/mutex.hpp>

struct OneMethodAS3VecStat {
	bool user_cancel;
	DWORD as3_method_jit_time;
	unsigned int vec_created_number;
	std::vector<void*> as3_vec_objects;
};
struct AS3VecStat{
	DWORD thread_id;
	std::vector<OneMethodAS3VecStat> stat_list;
};

class ExploitVerifier {
public:
	enum AS3EXEEVENT {
		AS3EXEEVENT_JIT,
		AS3EXEEVENT_CREATE_INT_VEC,
		AS3EXEEVENT_CREATE_UINT_VEC,
	};

	void EventNotify(AS3EXEEVENT evt, void* data = NULL);
	static ExploitVerifier* GetInstance();
private:
	static ExploitVerifier* instance_;

	void HandleJitEvt(void* name);
	void HandleVecEvt(void* vec_object);
	void HandleIntVecEvt(void* vec_object);
	void HandleUIntVecEvt(void* vec_object);
	bool OnExploit();
	void OnReadAs3VecLenException(unsigned int* address = 0);
	void OnReadAs3VecLenFailed(unsigned int* address = 0);
	void OnReadAs3VecLenSucced(unsigned int len, unsigned int* address = 0);
	void OnReadAs3VecLenFA(unsigned int len, unsigned int* address = 0);
	void RetireAS3VecStats(std::vector<OneMethodAS3VecStat>& vec);
	bool IsTimeOut(DWORD cur_time, DWORD init_time);
	bool CheckAS3Vector(OneMethodAS3VecStat& vec_stat);
	ExploitVerifier();
	~ExploitVerifier();

	boost::mutex m_lock;
	//boost::mutex::scoped_lock lock(io_mutex);
	std::map<DWORD, AS3VecStat> as3_vec_stats_map_;
	static const DWORD retire_interval_ = (2 * 60 * 1000);
	static const unsigned int as3_vec_num_threshold_ = 0x4;
};