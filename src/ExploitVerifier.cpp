#include "stdafx.h"
#include "ExploitVerifier.h"
#include "logger.h"
#include "fp_memory_dumper.h"
#include "fp_util.h"
#include "profile_helper.h"
extern std::wstring g_cur_url;
ExploitVerifier* ExploitVerifier::instance_ = NULL;

ExploitVerifier* ExploitVerifier::GetInstance() {
	if (instance_ == NULL) {
		instance_ = new ExploitVerifier;
	}

	return instance_;
}

ExploitVerifier::ExploitVerifier() {

}

ExploitVerifier::~ExploitVerifier() {

}

bool ExploitVerifier::IsTimeOut(DWORD cur_time, DWORD init_time) {
	unsigned long long ullMax = 0x100000000;
	DWORD dwInterval = ullMax + cur_time - init_time;


	if (dwInterval >= retire_interval_)
	{
		return true;
	}

	return false;
}

void ExploitVerifier::RetireAS3VecStats(std::vector<OneMethodAS3VecStat>& vec) {
	PF_SCOPE_PROFILE;

	//LOG_TRACE_EX("RetireAS3VecStats");
	DWORD cur_time = GetTickCount();
	bool need_retire = false;
	int index = 0;
	for (auto item : vec) {
		++index;
		DWORD init_time = item.as3_method_jit_time;
		if (IsTimeOut(cur_time, init_time)) {
			need_retire = true;
		} else {
			break;
		}
	}

	if (need_retire) {
		LOG_TRACE_EX("Need to retire, the index is " << index);
		vec.erase(vec.begin(), vec.begin() + index);
	}


}

void ExploitVerifier::OnReadAs3VecLenSucced(unsigned int len, unsigned int* address) {
	LOG_TRACE_EX("Suspicious Exploit, Length is [" << std::hex << len 
		<< "], Address is [" << std::hex << address << "], Next 4bytes is [" << std::hex << *(address + 4)
		<< "], Current URL is [" << g_cur_url.c_str() << "]");
}
void ExploitVerifier::OnReadAs3VecLenFailed(unsigned int* address) {
	LOG_TRACE_EX("Read AS3 vector length falied, address is " << std::hex << address);
}
void ExploitVerifier::OnReadAs3VecLenException(unsigned int* address) {

}
void ExploitVerifier::OnReadAs3VecLenFA(unsigned int len, unsigned int* address) {
	LOG_TRACE_EX("FA Exploit, Length is [" << std::hex << len 
		<< "], Address is [" << std::hex << address << "], Next 4bytes is [" << std::hex << *(address + 4)
		<< "], Current URL is [" << g_cur_url.c_str() << "]");
}
bool ExploitVerifier::CheckAS3Vector(OneMethodAS3VecStat& stat) {
	if (stat.vec_created_number >= as3_vec_num_threshold_ && !stat.user_cancel) {
		std::vector<void*>::iterator iter;
		for (iter = stat.as3_vec_objects.begin(); iter != stat.as3_vec_objects.end();) {
			unsigned int vec_len = 0;
			unsigned char* vec_object_pointer = NULL;
			unsigned int* data_list = NULL;
			__try {
				vec_object_pointer = (unsigned char*)*iter;
				data_list = (unsigned int*)*(unsigned int*)(vec_object_pointer + 0x18);
				vec_len = *(data_list);
				//OnReadAs3VecLenSucced(vec_len);
			} __except(EXCEPTION_EXECUTE_HANDLER ) {
				OnReadAs3VecLenException();
				iter = stat.as3_vec_objects.erase(iter);
				continue;
			}

			if ((unsigned int)data_list % 4 != 0) {
				//LOG_TRACE_EX("data list address is wrong, address is " << std::hex << data_list);
				OnReadAs3VecLenFailed();
				iter = stat.as3_vec_objects.erase(iter);
				continue;
			}

			if (vec_len >= 0x10000000 && vec_len <= 0x50000000 && (unsigned int)data_list <= 0x30000000) {
				OnReadAs3VecLenSucced(vec_len, data_list);
				iter = stat.as3_vec_objects.erase(iter);
				if (!OnExploit()) {
					// user cancel it, clear stats
					stat.user_cancel = true;
					return false;
				} 
				continue;
			} else if (vec_len > 0x50000000 || (vec_len >= 0x10000000 && (unsigned int)data_list > 0x20000000)) {
				OnReadAs3VecLenFA(vec_len, data_list);
				iter = stat.as3_vec_objects.erase(iter);
				continue;
			}
			++iter;
		}
		
	}
	return false;
}
void ExploitVerifier::HandleJitEvt(void* name) {
	PF_SCOPE_PROFILE;
	//if (!g_cur_url.empty()) {
    LOG_TRACE_EX("Jit method name [" << (char*)name << "]" << ", Current url = [" << g_cur_url.c_str() << "]");
		//g_cur_url = L"";
	//}
	
	DWORD thread_id = GetCurrentThreadId();

	boost::mutex::scoped_lock lock(m_lock);
	bool isExploit = false;
	std::map<DWORD, AS3VecStat>::iterator iter = as3_vec_stats_map_.find(thread_id);
	if (iter != as3_vec_stats_map_.end()) {
		std::vector<OneMethodAS3VecStat>& vec = iter->second.stat_list;
		RetireAS3VecStats(vec);
		std::vector<OneMethodAS3VecStat>::iterator iter;
		for (iter = vec.begin(); iter != vec.end(); ++iter) {
			isExploit = CheckAS3Vector(*iter);
		}

		if (!isExploit) {
			OneMethodAS3VecStat stat;
			stat.as3_method_jit_time = GetTickCount();
			stat.vec_created_number = 0;
			stat.user_cancel = false;

			vec.push_back(stat);
			//LOG_TRACE_EX("Insert Jit method for thread, id = " << thread_id);
		}
		
	} else {
		
		OneMethodAS3VecStat stat;
		stat.as3_method_jit_time = GetTickCount();
		stat.vec_created_number = 0;
		stat.user_cancel = false;

		AS3VecStat vec_stat;
		vec_stat.stat_list.push_back(stat);
		vec_stat.thread_id = thread_id;

		as3_vec_stats_map_[thread_id] = vec_stat;
		//LOG_TRACE_EX("Insert Jit method for thread, id = " << thread_id);
	}
}

void ExploitVerifier::HandleVecEvt(void* vec_object) {
	DWORD thread_id = GetCurrentThreadId();

	boost::mutex::scoped_lock lock(m_lock);
	std::map<DWORD, AS3VecStat>::iterator iter = as3_vec_stats_map_.find(thread_id);
	if (iter != as3_vec_stats_map_.end()) {
		std::vector<OneMethodAS3VecStat>& tmp = iter->second.stat_list;
		OneMethodAS3VecStat& stat = tmp.back();
		stat.vec_created_number++;
		stat.as3_vec_objects.push_back(vec_object);

		unsigned int* data_list = (unsigned int*)*(unsigned int*)((char*)vec_object + 0x18);
		//LOG_TRACE_EX("Vec created number is " << stat.vec_created_number << ", the method jit time is " << stat.as3_method_jit_time
		//	<< ", vector object address is " << std::hex << vec_object << ", data list address is " << data_list);
	} else {
		LOG_TRACE_EX("Error, there is no thread id for this vec creating");
	}
}

void ExploitVerifier::HandleIntVecEvt(void* vec_object) {
	//LOG_TRACE_EX("HandleIntVecEvt");
	HandleVecEvt(vec_object);
}

void ExploitVerifier::HandleUIntVecEvt(void* vec_object) {
	//LOG_TRACE_EX("HandleUIntVecEvt");
	HandleVecEvt(vec_object);
}

void ExploitVerifier::EventNotify(AS3EXEEVENT evt, void* data) {
	switch (evt)
	{
	case ExploitVerifier::AS3EXEEVENT_JIT:
		HandleJitEvt(data);
		break;
	case ExploitVerifier::AS3EXEEVENT_CREATE_INT_VEC:
		HandleIntVecEvt(data);
		break;
	case ExploitVerifier::AS3EXEEVENT_CREATE_UINT_VEC:
		HandleUIntVecEvt(data);
		break;
	default:
		break;
	}
}

bool ExploitVerifier::OnExploit() {
	PF_SCOPE_PROFILE;

	// found exploit, create dump and notify user
	LOG_TRACE_EX("OnExploit");
	//FPMemoryDumper::CreateMiniDump();
	//while(1) {
	//	;
	//}
	//int result = ::MessageBox(NULL, TEXT("Found Flash Exploiting Event. \nYou can contact @heisecode or @LambdaTea for support! \nWant to stop visiting the page?"), 
	//								TEXT("Flash Exploiting Event Found"), MB_ICONINFORMATION|MB_YESNO);
	//switch(result) {
	//case IDYES:
	//	// crash IE tab process or exit tab process
	//	//FPUtil::Crash();
	//	::ExitProcess(-1);
	//	break;
	//case IDNO:
	//	// not impact user
	//	break;
	//default:
	//	break;
	//}
	return true;
}